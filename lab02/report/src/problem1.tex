\CWHeader{Лабораторная работа \textnumero 2.1}

\CWProblem{
Реализовать методы простой итерации и Ньютона решения нелинейных уравнений в виде программ, 
задавая в качестве входных данных точность вычислений. С использованием разработанного программного обеспечения найти 
положительный корень нелинейного уравнения (начальное приближение определить графически). Проанализировать зависимость погрешности 
вычислений от количества итераций. 

$$
x^4 - 2x - 1= 0
$$
}

\section*{Описание}

Численное решение нелинейных (алгебраических или трансцендентных) уравнений
вида 

\[
f(x) = 0 \tag{2.1}
\]

заключается в нахождении значений x, удовлетворяющих (с заданной точностью) данному
уравнению и состоит из следующих основных этапов:

\begin{enumerate}
    \item Отделение (изоляция, локализация) корней уравнения. \\
    \item Уточнение с помощью некоторого вычислительного алгоритма конкретного
выделенного корня с заданной точностью. \\
\end{enumerate}

Целью первого этапа является нахождение отрезков из области определения функции $f(x)$,
внутри которых содержится только один корень решаемого уравнения. Иногда
ограничиваются рассмотрением лишь какой-нибудь части области определения,
вызывающей по тем или иным соображениям интерес. Для реализации данного этапа
используются графические или аналитические способы. 

При завершении первого этапа, должны быть определены промежутки,
на каждом из которых содержится только один корень уравнения. 

Для уточнения корня с требуемой точностью обычно применяется какой-либо
итерационный метод, заключающийся в построении числовой последовательности
$x^{(k)}$ ($k = 0, 1, 2, ...$), сходящейся к искомому корню $x^{(*)}$ уравнения (2.1)

\subsection*{Метод простой итерации}
При использовании метода простой итерации уравнение 
\[ f(x) = 0 \tag{2.1} \]
заменяется эквивалентным уравнением с выделенным линейным членом:
\[ x = \varphi(x). \tag{2.5} \]

Решение ищется путём построения последовательности:
\[ x^{(k+1)} = \varphi(x^{(k)}), \quad k = 0, 1, 2, \ldots \tag{2.6} \]
начиная с некоторого заданного значения \( x^{(0)} \). 

Если \( \varphi(x) \) — непрерывная функция, а последовательность \( \{x^{(k)}\} \) сходится, то значение \( x^{(s)} = \lim_{k \to \infty} x^{(k)} \) является решением уравнения (2.5).

Условия сходимости метода и оценка его погрешности определяются теоремой:

\begin{theorem}[2.3]
Пусть функция \( \varphi(x) \) определена и дифференцируема на отрезке \([a, b]\). Тогда если выполняются условия:
\begin{enumerate}
    \item \( \varphi(x) \in [a, b] \quad \forall x \in [a, b] \),
    \item \( \exists q : |\varphi'(x)| \leq q < 1 \quad \forall x \in (a, b) \),
\end{enumerate}
то уравнение (2.5) имеет единственный корень \( x^{(s)} \) на \([a, b]\), и последовательность \( \{x^{(k)}\} \) сходится к \( x^{(s)} \) при любом \( x^{(0)} \in [a, b] \). При этом справедливы оценки погрешности:
\[
\left| x^{(s)} - x^{(k+1)} \right| \leq \frac{q}{1-q} \left| x^{(k+1)} - x^{(k)} \right|,
\]
\[
\left| x^{(s)} - x^{(k+1)} \right| \leq \frac{q^{k+1}}{1-q} \left| x^{(1)} - x^{(0)} \right|. \tag{2.7}
\]
\end{theorem}

\subsection*{Метод Ньютона (метод касательных)}
При нахождении корня уравнения 
\[ f(x) = 0 \tag{2.1} \]
методом Ньютона итерационный процесс определяется формулой:
\[
x^{(k+1)} = x^{(k)} - \frac{f(x^{(k)})}{f'(x^{(k)})}, \quad k = 0,1,2,\ldots \tag{2.2}
\]
Для начала вычислений требуется задание начального приближения \( x^{(0)} \).

Условия сходимости метода определяются следующей теоремой:

\begin{theorem}[2.2]
Пусть на отрезке \([a,b]\) функция \( f(x) \) имеет первую и вторую производные постоянного знака и пусть \( f(a)f(b) < 0 \). Тогда если точка \( x^{(0)} \) выбрана на \([a,b]\) так, что
\[
f(x^{(0)})f''(x^{(0)}) > 0, \tag{2.3}
\]
то начатая с неё последовательность \( \{x^{(k)}\} \) (\( k=0,1,2,\ldots \)), определяемая методом Ньютона (2.2), монотонно сходится к корню \( x^{(v)} \in (a,b) \) уравнения (2.1).
\end{theorem}

\section*{Исходный код}

\begin{minted}{java}
package cat.mood;

import java.util.function.Function;

public class A {
    public static double derivative(Function<Double, Double> f, double x, double eps) {
        double dy = f.apply(x + eps) - f.apply(x);
        return dy / eps;
    }

    public static double secondDerivative(Function<Double, Double> f, double x, double eps) {
        double fPlus = f.apply(x + eps);
        double fMinus = f.apply(x - eps);
        double fCenter = f.apply(x);

        return (fPlus - 2 * fCenter + fMinus) / (eps * eps);
    }

    public static boolean checkFunction(Function<Double, Double> phi, double eps, double a, double b) {
        double x = a;
        while (x < b) {
            double y = phi.apply(x);
            if (y < a || y > b) {
                return false;
            }
            if (Math.abs(derivative(phi, x, eps)) >= 1) {
                return false;
            }
            x += eps;
        }

        return true;
    }

    public static double iteration(Function<Double, Double> phi, double eps, double a, double b) {
        boolean check = checkFunction(phi, eps, a, b);
        if (!check) {
            throw new RuntimeException("Не выполнено условие сходимости");
        }

        double prev = a;
        double cur = phi.apply(prev);
        int iters = 1;
        while (Math.abs(cur - prev) > eps) {
            prev = cur;
            cur = phi.apply(prev);
            ++iters;
        }

        System.out.println("Количество итераций: " + iters);

        return cur;
    }

    public static double newton(Function<Double, Double> f, double eps, double a, double b) {
        if (f.apply(a) * f.apply(b) >= 0) {
            throw new RuntimeException("Не выполнено условие сходимости");
        }

        double prev = b;
        while (prev > a) {
            if (f.apply(prev) * secondDerivative(f, prev, eps) > 0) {
                break;
            }
            prev -= eps;
        }
        if (f.apply(prev) * secondDerivative(f, prev, eps) <= 0) {
            throw new RuntimeException("Не выполнено условие сходимости");
        }
        int iters = 1;
        double cur = prev - f.apply(prev) / derivative(f, prev, eps);
        while (Math.abs(cur - prev) > eps) {
            prev = cur;
            cur = prev - f.apply(prev) / derivative(f, prev, eps);
            ++iters;
        }

        System.out.println("Количество итераций: " + iters);

        return cur;
    }

    public static void main(String[] args) {
        System.out.println("Метод простой итерации:");
        System.out.println(iteration(x -> (Math.pow(2 * x + 1, 0.25)), 0.000001, 0, 2));
        System.out.println("Метод Ньютона:");
        System.out.println(newton(x -> (Math.pow(x, 4) - 2 * x - 1), 0.000001, 0, 2));
    }
}
\end{minted}

\section*{Результат}

\begin{minted}{bash}
Метод простой итерации:
Количество итераций: 10
1.3953368880468564
Метод Ньютона:
Количество итераций: 6
1.3953369944670735
\end{minted}

\section*{Вывод}

В ходе выполнения работы были успешно реализованы и протестированы два численных метода решения нелинейных уравнений: 
метод простой итерации и метод Ньютона. Проведенные вычисления позволили сделать следующие выводы:

\textbf{Сходимость методов}:
\begin{itemize}
\item Метод Ньютона продемонстрировал более быструю сходимость (6 итераций) по сравнению с методом простой итерации (10 итераций)
\item Оба метода сошлись к близким значениям корня: 1.395336888 (простая итерация) и 1.395336994 (метод Ньютона)
\end{itemize}

\textbf{Точность результатов}:
Различие между полученными значениями составляет около $1.06 \times 10^{-7}$, что свидетельствует о хорошей точности обоих методов

\textbf{Эффективность методов}:
\begin{itemize}
\item Метод Ньютона оказался более эффективным по количеству требуемых итераций
\item Метод простой итерации, хотя и потребовал больше вычислений, проще в реализации и не требует вычисления производной
\end{itemize}

Результаты работы подтвердили теоретические положения о скорости сходимости рассматриваемых методов и продемонстрировали 
их практическую применимость для решения нелинейных уравнений.

\pagebreak
